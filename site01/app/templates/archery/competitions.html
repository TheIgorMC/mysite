{% extends "base.html" %}

{% block title %}{{ t('archery.competitions') }} - {{ super() }}{% endblock %}

{% block content %}
<section class="py-12 bg-gray-100 dark:bg-gray-900 min-h-screen">
    <div class="container mx-auto p        if (authAthletesResp.ok) {
            const authData = await authAthletesResp.json();
            authorizedAthletes = authData.authorized_athletes || [];
        }
        
        // Load competitions from Flask proxy (which calls FastAPI with auth)
        const gareResp = await fetch(`/archery/api/gare?future=true&limit=100`);-7xl">
        <!-- Header -->
        <div class="mb-8">
            <a href="{{ url_for('archery.index') }}" 
               class="inline-flex items-center text-primary hover:text-primary-dark mb-4 transition">
                <i class="fas fa-arrow-left mr-2"></i>{{ t('common.back') }}
            </a>
            <h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-2">{{ t('archery.competitions') }}</h1>
            <p class="text-gray-600 dark:text-gray-400">{{ t('archery.competitions_subtitle') }}</p>
        </div>

        <!-- Filter Tabs -->
        <div class="mb-6">
            <div class="border-b border-gray-300 dark:border-gray-700">
                <nav class="flex space-x-4" aria-label="Tabs">
                    <button onclick="filterCompetitions('upcoming')" 
                            id="tab-upcoming"
                            class="tab-button active px-4 py-2 font-medium text-sm border-b-2 border-primary text-primary">
                        {{ t('competitions.upcoming') }}
                    </button>
                    <button onclick="filterCompetitions('open')" 
                            id="tab-open"
                            class="tab-button px-4 py-2 font-medium text-sm border-b-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-primary hover:border-gray-300">
                        {{ t('competitions.open_subscriptions') }}
                    </button>
                    <button onclick="filterCompetitions('my')" 
                            id="tab-my"
                            class="tab-button px-4 py-2 font-medium text-sm border-b-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-primary hover:border-gray-300">
                        {{ t('competitions.my_subscriptions') }}
                    </button>
                    <button onclick="filterCompetitions('interested')" 
                            id="tab-interested"
                            class="tab-button px-4 py-2 font-medium text-sm border-b-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-primary hover:border-gray-300">
                        <i class="fas fa-star mr-1"></i>Le mie espressioni di interesse
                    </button>
                </nav>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading" class="hidden flex justify-center items-center py-12">
            <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary border-t-transparent"></div>
        </div>

        <!-- Competitions Grid -->
        <div id="competitions-grid" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Competitions will be loaded here by JavaScript -->
        </div>

        <!-- Empty State -->
        <div id="empty-state" class="hidden text-center py-12">
            <i class="fas fa-calendar-times text-6xl text-gray-400 mb-4"></i>
            <p class="text-gray-600 dark:text-gray-400 text-lg">{{ t('competitions.no_competitions') }}</p>
        </div>
    </div>
</section>

<!-- Competition Card Template -->
<template id="competition-card-template">
    <div class="competition-card bg-white dark:bg-gray-800 rounded-lg shadow-md hover:shadow-xl transition-shadow duration-300">
        <div class="p-6">
            <!-- Header -->
            <div class="flex items-start justify-between mb-4">
                <div class="flex-1">
                    <h3 class="competition-name text-xl font-bold text-gray-900 dark:text-white mb-1"></h3>
                    <span class="competition-code text-xs font-mono text-gray-500 dark:text-gray-400 block mb-2"></span>
                    <div class="flex items-center text-sm text-gray-600 dark:text-gray-400 mb-1">
                        <i class="fas fa-map-marker-alt mr-2"></i>
                        <span class="competition-location"></span>
                    </div>
                    <div class="flex items-center text-sm text-gray-600 dark:text-gray-400">
                        <i class="fas fa-calendar mr-2"></i>
                        <span class="competition-date"></span>
                    </div>
                </div>
                <span class="competition-badge px-3 py-1 rounded-full text-xs font-semibold"></span>
            </div>

            <!-- Details -->
            <div class="space-y-2 mb-4">
                <div class="flex items-center text-sm text-gray-700 dark:text-gray-300">
                    <i class="fas fa-bullseye mr-2 text-primary"></i>
                    <span class="competition-type"></span>
                </div>
                <div class="competition-category-container hidden flex items-center text-sm text-gray-700 dark:text-gray-300">
                    <i class="fas fa-tag mr-2 text-primary"></i>
                    <span class="competition-category"></span>
                </div>
                <div class="competition-deadline-container hidden flex items-center text-sm text-gray-700 dark:text-gray-300">
                    <i class="fas fa-clock mr-2 text-primary"></i>
                    <span>{{ t('competitions.deadline') }}: <span class="competition-deadline"></span></span>
                </div>
            </div>

            <!-- Subscription Status -->
            <div class="competition-subscription-status hidden mb-4 p-3 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg">
                <div class="flex items-center justify-between text-sm">
                    <div class="flex items-center text-green-800 dark:text-green-300 cursor-pointer hover:opacity-80 transition flex-1" onclick="toggleAthleteList(this)">
                        <i class="fas fa-check-circle mr-2"></i>
                        <span>{{ t('competitions.subscribed') }}</span>
                        <i class="fas fa-chevron-down ml-2 text-xs athlete-list-toggle"></i>
                    </div>
                    <button class="btn-unsubscribe text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-300 px-2 py-1 rounded transition" title="{{ t('competitions.delete_subscription') }}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                <div class="athlete-list hidden mt-3 pt-3 border-t border-green-200 dark:border-green-800 space-y-2">
                    <!-- Athletes will be populated here -->
                </div>
            </div>

            <!-- Interest Status -->
            <div class="competition-interest-status hidden mb-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg">
                <div class="flex items-center justify-between text-sm">
                    <div class="flex items-center text-yellow-800 dark:text-yellow-300 cursor-pointer hover:opacity-80 transition flex-1" onclick="toggleAthleteList(this)">
                        <i class="fas fa-star mr-2"></i>
                        <span class="interest-status-text">Interesse espresso</span>
                        <i class="fas fa-chevron-down ml-2 text-xs athlete-list-toggle"></i>
                    </div>
                    <button class="btn-delete-interest text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-300 px-2 py-1 rounded transition" title="Rimuovi interesse">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                <div class="athlete-list hidden mt-3 pt-3 border-t border-yellow-200 dark:border-yellow-800 space-y-2">
                    <!-- Athletes will be populated here -->
                </div>
            </div>

            <!-- Actions -->
            <div class="flex gap-2">
                <button class="btn-subscribe w-full bg-primary hover:bg-primary-dark text-white px-4 py-2 rounded-lg transition font-medium">
                    <i class="fas fa-user-plus mr-2"></i>Iscriviti
                </button>
            </div>
        </div>
    </div>
</template>

<!-- Subscription Modal -->
<div id="subscription-modal" class="fixed inset-0 z-50 hidden overflow-y-auto">
    <div class="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
        <!-- Background overlay -->
        <div class="fixed inset-0 transition-opacity bg-gray-500 bg-opacity-75" onclick="closeSubscriptionModal()"></div>

        <!-- Modal panel -->
        <div class="inline-block align-bottom bg-white dark:bg-gray-800 rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full">
            <div class="bg-white dark:bg-gray-800 px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                <div class="sm:flex sm:items-start">
                    <div class="mt-3 text-center sm:mt-0 sm:text-left w-full">
                        <h3 class="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4" id="modal-title">
                            Iscriviti alla Gara
                        </h3>
                        <div class="mt-2">
                            <p class="text-sm text-gray-600 dark:text-gray-400 mb-4" id="modal-competition-info"></p>
                            
                            <form id="subscription-form">
                                <input type="hidden" id="competition-id" name="competition_id">
                                
                                <!-- Athlete Selection -->
                                <div class="mb-4">
                                    <label for="selected-athlete" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Seleziona Atleta
                                    </label>
                                    <div id="athlete-select-container">
                                        <!-- Populated by JavaScript -->
                                    </div>
                                </div>
                                
                                <div class="mb-4">
                                    <label for="age-category" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Categoria di Età
                                    </label>
                                    <select id="age-category" name="age_category" 
                                            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                                        <option value="">Seleziona categoria...</option>
                                        <option value="GM">GM - Giovanissimi Maschile</option>
                                        <option value="GF">GF - Giovanissimi Femminile</option>
                                        <option value="RM">RM - Ragazzi Maschile</option>
                                        <option value="RF">RF - Ragazzi Femminile</option>
                                        <option value="AM">AM - Allievi Maschile</option>
                                        <option value="AF">AF - Allievi Femminile</option>
                                        <option value="JM">JM - Juniores Maschile</option>
                                        <option value="JF">JF - Juniores Femminile</option>
                                        <option value="SM">SM - Seniores Maschile</option>
                                        <option value="SF">SF - Seniores Femminile</option>
                                        <option value="MM">MM - Master Maschile</option>
                                        <option value="MF">MF - Master Femminile</option>
                                    </select>
                                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                        <i class="fas fa-info-circle mr-1"></i>Categoria determinata dall'età dell'atleta
                                    </p>
                                </div>
                                
                                <div class="mb-4">
                                    <label for="bow-type" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Tipo di Arco
                                    </label>
                                    <select id="bow-type" name="bow_type" required
                                            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                                        <option value="">Seleziona arco...</option>
                                        <option value="CO">CO - Compound</option>
                                        <option value="OL">OL - Olympic Recurve</option>
                                        <option value="AN">AN - Barebow</option>
                                    </select>
                                </div>
                                
                                <div id="turn-selection-container" class="mb-4">
                                    <label for="turn" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Seleziona Turno
                                    </label>
                                    <select id="turn" name="turn" 
                                            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                                        <option value="">Scegli turno...</option>
                                    </select>
                                </div>

                                <div class="mb-4">
                                    <label for="notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Note (Opzionale)
                                    </label>
                                    <textarea id="notes" name="notes" rows="3"
                                              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                                              placeholder="Aggiungi note o preferenze..."></textarea>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
            <div class="bg-gray-50 dark:bg-gray-900 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                <button type="button" id="modal-submit-btn" onclick="submitSubscription()"
                        class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-primary text-base font-medium text-white hover:bg-primary-dark sm:ml-3 sm:w-auto sm:text-sm">
                    Conferma Iscrizione
                </button>
                <button type="button" onclick="closeSubscriptionModal()"
                        class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-gray-600 shadow-sm px-4 py-2 bg-white dark:bg-gray-800 text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 sm:mt-0 sm:w-auto sm:text-sm">
                    Annulla
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Subscription Modal -->
<div id="delete-subscription-modal" class="fixed z-50 inset-0 overflow-y-auto hidden">
    <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 dark:bg-gray-900 bg-opacity-75 dark:bg-opacity-75 transition-opacity"></div>
        
        <div class="inline-block align-bottom bg-white dark:bg-gray-800 rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full">
            <div class="bg-white dark:bg-gray-800 px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                <div class="sm:flex sm:items-start">
                    <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900/30 sm:mx-0 sm:h-10 sm:w-10">
                        <i class="fas fa-trash text-red-600 dark:text-red-400"></i>
                    </div>
                    <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
                        <h3 class="text-lg leading-6 font-medium text-gray-900 dark:text-white" id="delete-modal-title">
                            Elimina Iscrizioni
                        </h3>
                        <div class="mt-4">
                            <p class="text-sm text-gray-500 dark:text-gray-400 mb-4" id="delete-modal-competition-info">
                                Seleziona le iscrizioni da eliminare:
                            </p>
                            <div id="delete-subscriptions-list" class="space-y-2">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="bg-gray-50 dark:bg-gray-900 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                <button type="button" onclick="confirmDeleteSelected()"
                        class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 sm:ml-3 sm:w-auto sm:text-sm">
                    <i class="fas fa-trash mr-2"></i>Elimina Selezionate
                </button>
                <button type="button" onclick="closeDeleteModal()"
                        class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-gray-600 shadow-sm px-4 py-2 bg-white dark:bg-gray-800 text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 sm:mt-0 sm:w-auto sm:text-sm">
                    Annulla
                </button>
            </div>
        </div>
    </div>
</div>

<script>
// Configuration - Use Flask proxy endpoints (no direct API calls)
// All API calls go through Flask backend which handles Cloudflare Access

// IMPORTANT: Field naming inconsistency between tables:
// - authorized_athletes table: categoria=age_category (SM/SF/etc), classe=bow_type (CO/OL/AN)
// - ARC_iscrizioni table: categoria=bow_type (CO/OL/AN), classe=age_category (SM/SF/etc)
// They are REVERSED! This is why we read athlete.categoria but submit it as classe to iscrizioni API.

let currentFilter = 'upcoming';
let allCompetitions = [];
let allInviti = {};  // Invitation details mapped by codice_gara
let allTurni = {};   // Turns mapped by codice_gara
let userSubscriptions = new Map();  // Map of codice_gara -> array of subscription objects
let userInterests = new Map();  // Map of codice_gara -> array of interest expressions
let authorizedAthletes = [];  // User's authorized athletes from website

// Interest expressions are now stored in ARC_interesse table (separate from subscriptions)

// Load competitions on page load
document.addEventListener('DOMContentLoaded', function() {
    loadInitialData();
});

async function loadInitialData() {
    console.log('Loading initial data...');
    showLoading(true);
    
    try {
        // Load authorized athletes from website
        const authAthletesResp = await fetch('/api/user/authorized-athletes');
        if (authAthletesResp.ok) {
            const authData = await authAthletesResp.json();
            authorizedAthletes = authData.authorized_athletes || [];
        }
        console.log('Loaded athletes:', authorizedAthletes.length);
        
        // Load competitions from Flask proxy (which calls FastAPI with auth)
        // Use future=true to only get future competitions (better performance)
        const gareResp = await fetch(`/archery/api/gare?future=true&limit=1000`);
        if (!gareResp.ok) throw new Error('Failed to load competitions');
        
        allCompetitions = await gareResp.json();
        console.log('Loaded competitions:', allCompetitions.length);
        console.log('Sample competition:', allCompetitions[0]);
        console.log('Competitions by societa_codice:', allCompetitions.reduce((acc, c) => {
            const prefix = c.societa_codice ? c.societa_codice.substring(0, 2) : 'null';
            acc[prefix] = (acc[prefix] || 0) + 1;
            return acc;
        }, {}));
        
        // Use mass export for faster loading
        await Promise.all([
            loadInvitiMassExport(),
            loadUserSubscriptionsMassExport(),
            loadUserInterestsMassExport()
        ]);
        console.log('Loaded inviti, subscriptions, and interests via mass export');
        console.log('Total inviti:', Object.keys(allInviti).length);
        console.log('Competitions without invites:', allCompetitions.filter(c => !allInviti[c.codice]).length);
        if (allCompetitions.length > 0) {
            const withoutInvites = allCompetitions.filter(c => !allInviti[c.codice]);
            if (withoutInvites.length > 0) {
                console.log('Sample competitions without invites:', withoutInvites.slice(0, 5).map(c => ({
                    codice: c.codice,
                    nome: c.nome,
                    data_inizio: c.data_inizio,
                    societa_codice: c.societa_codice
                })));
            }
        }
        
        console.log('Filtering competitions with filter:', currentFilter);
        filterCompetitions(currentFilter);
        console.log('Filter complete');
    } catch (error) {
        console.error('Error loading data:', error);
        showError('Failed to load competitions');
    } finally {
        // Always hide loading spinner
        console.log('Hiding spinner');
        showLoading(false);
    }
}

async function loadInvitiMassExport() {
    // Load ALL invites data from API in one request using mass export
    console.log('loadInvitiMassExport: Starting...');
    try {
        const resp = await fetch(`/archery/api/inviti?export=full`);
        console.log('loadInvitiMassExport: Fetch complete, status:', resp.status);
        if (resp.ok) {
            const inviti = await resp.json();
            console.log('loadInviti: Got', inviti.length, 'invites');
            // Map invites by codice for fast lookup
            inviti.forEach(invito => {
                allInviti[invito.codice] = invito;
                console.log(`  Mapped invite: ${invito.codice} -> apertura:${invito.data_apertura_iscrizioni}, chiusura:${invito.data_chiusura_iscrizioni}`);
            });
        } else {
            console.warn('loadInvitiMassExport: Response not OK:', resp.status);
        }
    } catch (error) {
        console.error('Error loading inviti:', error);
    }
    console.log('loadInvitiMassExport: Complete. Total mapped:', Object.keys(allInviti).length);
}

async function loadUserSubscriptionsMassExport() {
    if (authorizedAthletes.length === 0) return;
    
    console.log('loadUserSubscriptionsMassExport: Starting for', authorizedAthletes.length, 'athletes');
    try {
        // Use mass export to get ALL subscriptions in one request
        const resp = await fetch(`/archery/api/iscrizioni?export=full`);
        if (resp.ok) {
            const allSubscriptions = await resp.json();
            console.log('loadUserSubscriptionsMassExport: Received', allSubscriptions.length, 'total subscriptions');
            
            // Filter to only subscriptions for our authorized athletes
            const athleteTessere = new Set(authorizedAthletes.map(a => a.tessera));
            const userSubs = allSubscriptions.filter(sub => athleteTessere.has(sub.tessera_atleta));
            
            console.log('loadUserSubscriptionsMassExport: Filtered to', userSubs.length, 'subscriptions for our athletes');
            
            userSubs.forEach(sub => {
                // Store subscriptions as array per competition to support multiple athletes
                if (!userSubscriptions.has(sub.codice_gara)) {
                    userSubscriptions.set(sub.codice_gara, []);
                }
                userSubscriptions.get(sub.codice_gara).push(sub);
            });
        } else {
            console.warn('loadUserSubscriptionsMassExport: Response not OK:', resp.status);
        }
    } catch (error) {
        console.error('Error loading subscriptions via mass export:', error);
    }
    console.log('loadUserSubscriptionsMassExport: Complete. Subscriptions for', userSubscriptions.size, 'competitions');
}

async function loadUserInterestsMassExport() {
    if (authorizedAthletes.length === 0) return;
    
    console.log('loadUserInterestsMassExport: Starting for', authorizedAthletes.length, 'athletes');
    try {
        // Use mass export to get ALL interests in one request
        const resp = await fetch(`/archery/api/interesse?export=full`);
        if (resp.ok) {
            const allInterests = await resp.json();
            console.log('loadUserInterestsMassExport: Received', allInterests.length, 'total interests');
            
            // Filter to only interests for our authorized athletes
            const athleteTessere = new Set(authorizedAthletes.map(a => a.tessera));
            const userInts = allInterests.filter(int => athleteTessere.has(int.tessera_atleta));
            
            console.log('loadUserInterestsMassExport: Filtered to', userInts.length, 'interests for our athletes');
            
            userInts.forEach(interest => {
                // Store interests as array per competition to support multiple athletes
                if (!userInterests.has(interest.codice_gara)) {
                    userInterests.set(interest.codice_gara, []);
                }
                userInterests.get(interest.codice_gara).push(interest);
            });
        } else {
            console.warn('loadUserInterestsMassExport: Response not OK:', resp.status);
        }
    } catch (error) {
        console.error('Error loading interests via mass export:', error);
    }
    console.log('loadUserInterestsMassExport: Complete. Interests for', userInterests.size, 'competitions');
}

async function loadUserSubscriptions() {
    try {
        // DEPRECATED: Use loadUserSubscriptionsMassExport instead for better performance
        // Load subscriptions for all authorized athletes from Flask proxy
        for (const athlete of authorizedAthletes) {
            const resp = await fetch(`/archery/api/iscrizioni?tessera_atleta=${athlete.tessera}`);
            if (resp.ok) {
                const subscriptions = await resp.json();
                subscriptions.forEach(sub => {
                    // Store subscriptions as array per competition to support multiple athletes
                    if (!userSubscriptions.has(sub.codice_gara)) {
                        userSubscriptions.set(sub.codice_gara, []);
                    }
                    userSubscriptions.get(sub.codice_gara).push(sub);
                });
            }
        }
    } catch (error) {
        console.error('Error loading user subscriptions:', error);
    }
}

/**
 * Get competition status based on dates and invite data
 * Returns: {
 *   status: 'iscrizioni_chiuse'|'iscrizioni_aperte'|'in_arrivo'|'attesa_invito',
 *   canSubscribe: boolean,
 *   label: string,
 *   color: string (CSS classes)
 * }
 */
function getCompetitionStatus(competition) {
    // Parse dates in local timezone to avoid UTC conversion issues
    const now = new Date();
    now.setHours(0, 0, 0, 0); // Compare dates only, not times
    
    // Parse date strings as local dates (YYYY-MM-DD)
    const parseLocalDate = (dateStr) => {
        if (!dateStr) return null;
        const [year, month, day] = dateStr.split('-').map(Number);
        const date = new Date(year, month - 1, day); // month is 0-indexed
        date.setHours(0, 0, 0, 0);
        return date;
    };
    
    const startDate = parseLocalDate(competition.data_inizio);
    
    const invito = allInviti[competition.codice];
    
    console.log(`Status for ${competition.codice} (${competition.nome}):`, {
        has_invito: !!invito,
        invito_data: invito,
        start_date: competition.data_inizio
    });
    
    // No invite associated = "attesa invito" (white)
    if (!invito) {
        return {
            status: 'attesa_invito',
            canSubscribe: false,
            canExpressInterest: true,
            label: window.translations.attesa_invito || 'Attesa invito',
            color: 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200'
        };
    }
    
    const aperturaDate = parseLocalDate(invito.data_apertura_iscrizioni);
    const chiusuraDate = parseLocalDate(invito.data_chiusura_iscrizioni);
    
    console.log(`  Dates: now=${now.toLocaleDateString()}, apertura=${aperturaDate?.toLocaleDateString()}, chiusura=${chiusuraDate?.toLocaleDateString()}, start=${startDate?.toLocaleDateString()}`);
    
    // Competition started OR subscription window closed = "iscrizioni chiuse" (red)
    if (startDate <= now || chiusuraDate < now) {
        console.log(`  → Status: CHIUSE (started=${startDate <= now}, closed=${chiusuraDate < now})`);
        return {
            status: 'iscrizioni_chiuse',
            canSubscribe: false,
            canExpressInterest: false,
            label: window.translations.iscrizioni_chiuse || 'Iscrizioni chiuse',
            color: 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300'
        };
    }
    
    // Subscription window is currently open = "iscrizioni aperte" (green)
    if (now >= aperturaDate && now <= chiusuraDate && startDate > now) {
        console.log(`  → Status: APERTE`);
        return {
            status: 'iscrizioni_aperte',
            canSubscribe: true,
            canExpressInterest: false,
            label: window.translations.iscrizioni_aperte || 'Iscrizioni aperte',
            color: 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300'
        };
    }
    
    // Subscription opens in the future = "in arrivo" (blue)
    if (aperturaDate > now && startDate > now) {
        console.log(`  → Status: IN ARRIVO`);
        return {
            status: 'in_arrivo',
            canSubscribe: true,  // Allow subscribing even if not yet open
            canExpressInterest: false,
            label: window.translations.in_arrivo || 'In arrivo',
            color: 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300'
        };
    }
    
    // Fallback (shouldn't reach here)
    console.log(`  → Status: FALLBACK (attesa invito)`);
    return {
        status: 'attesa_invito',
        canSubscribe: false,
        canExpressInterest: true,
        label: 'Attesa invito',
        color: 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200'
    };
}

function filterCompetitions(filter) {
    currentFilter = filter;
    
    console.log('=== filterCompetitions called with:', filter);
    console.log('Total competitions:', allCompetitions.length);
    
    // Update tab styling
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active', 'border-primary', 'text-primary');
        btn.classList.add('border-transparent', 'text-gray-600', 'dark:text-gray-400');
    });
    document.getElementById(`tab-${filter}`).classList.add('active', 'border-primary', 'text-primary');
    document.getElementById(`tab-${filter}`).classList.remove('border-transparent', 'text-gray-600', 'dark:text-gray-400');
    
    // Filter competitions based on selected tab
    let filtered = [];
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    
    console.log('Current date for filtering:', now.toISOString());
    
    switch(filter) {
        case 'upcoming':
            // Future competitions (not ended yet) - region 06 only
            console.log('Filtering for upcoming competitions...');
            filtered = allCompetitions.filter(c => {
                const endDate = new Date(c.data_fine);
                endDate.setHours(0, 0, 0, 0);
                const isUpcoming = endDate >= now;
                if (!isUpcoming) {
                    console.log(`  ${c.nome} (${c.codice}): PAST (end: ${c.data_fine})`);
                }
                return isUpcoming;
            });
            console.log('After date filter:', filtered.length);
            break;
        case 'open':
            // Competitions with OPEN subscription windows (today between apertura and chiusura dates)
            filtered = allCompetitions.filter(c => {
                const invito = allInviti[c.codice];
                if (!invito) return false;  // No invite = not open
                
                const aperturaDate = new Date(invito.data_apertura_iscrizioni);
                aperturaDate.setHours(0, 0, 0, 0);
                const chiusuraDate = new Date(invito.data_chiusura_iscrizioni);
                chiusuraDate.setHours(0, 0, 0, 0);
                const startDate = new Date(c.data_inizio);
                startDate.setHours(0, 0, 0, 0);
                
                // Open if: today is between apertura and chiusura, and competition hasn't started
                return now >= aperturaDate && now <= chiusuraDate && startDate > now;
            });
            break;
        case 'my':
            // User's subscriptions (actual subscriptions only)
            filtered = allCompetitions.filter(c => userSubscriptions.has(c.codice));
            break;
        case 'interested':
            // Competitions where user expressed interest
            filtered = allCompetitions.filter(c => userInterests.has(c.codice));
            break;
        default:
            // Default to upcoming
            filtered = allCompetitions.filter(c => {
                const endDate = new Date(c.data_fine);
                endDate.setHours(0, 0, 0, 0);
                return endDate >= now;
            });
            break;
    }
    
    // Filter by region 06 (Veneto) based on societa_codice
    // Show ALL region 06 competitions, including those WITHOUT published invites
    // Users can express interest in competitions without invites
    console.log('Before region filter:', filtered.length);
    const beforeRegionFilter = filtered.length;
    filtered = filtered.filter(c => c.societa_codice && c.societa_codice.startsWith('06'));
    console.log('After region 06 filter:', filtered.length);
    if (filtered.length === 0 && beforeRegionFilter > 0) {
        console.warn('ALL competitions filtered out by region filter!');
        console.log('Sample societa_codice values:', allCompetitions.slice(0, 5).map(c => ({
            nome: c.nome,
            societa_codice: c.societa_codice
        })));
    }
    
    console.log('Final filtered competitions:', filtered.length);
    renderCompetitions(filtered);
}

/**
 * Get subscription summary for a competition (handles multiple athletes)
 * Returns: { hasActiveSubscription, allCancelled, statusText, statusColor, primaryStatus, subscriptions }
 */
function getSubscriptionSummary(codiceGara) {
    if (!userSubscriptions.has(codiceGara)) {
        return { hasActiveSubscription: false, allCancelled: false, subscriptions: [] };
    }
    
    const subs = userSubscriptions.get(codiceGara);
    const activeSubs = subs.filter(s => s.stato !== 'cancellato');
    
    if (activeSubs.length === 0) {
        return { hasActiveSubscription: false, allCancelled: true, subscriptions: subs };
    }
    
    // Count by status
    const confirmed = activeSubs.filter(s => s.stato === 'confermato').length;
    const waiting = activeSubs.filter(s => s.stato === 'in attesa').length;
    const pending = activeSubs.filter(s => s.stato === 'richiesta_effettuata').length;
    
    // Determine primary status (priority: confirmed > waiting > pending)
    let primaryStatus, statusText, statusColor, statusIcon;
    if (confirmed > 0) {
        primaryStatus = 'confermato';
        statusIcon = 'fas fa-check-circle';
        statusColor = 'green';
        statusText = confirmed === 1 ? 'Iscritto' : `${confirmed} iscritti`;
    } else if (waiting > 0) {
        primaryStatus = 'in attesa';
        statusIcon = 'fas fa-clock';
        statusColor = 'yellow';
        statusText = waiting === 1 ? 'In attesa' : `${waiting} in attesa`;
    } else {
        primaryStatus = 'richiesta_effettuata';
        statusIcon = 'fas fa-paper-plane';
        statusColor = 'gray';
        statusText = pending === 1 ? 'Richiesta effettuata' : `${pending} richieste`;
    }
    
    return { 
        hasActiveSubscription: true, 
        allCancelled: false,
        primaryStatus, 
        statusText, 
        statusColor,
        statusIcon,
        subscriptions: subs,
        activeSubs,
        confirmed,
        waiting,
        pending
    };
}

function renderCompetitions(competitions) {
    const grid = document.getElementById('competitions-grid');
    const emptyState = document.getElementById('empty-state');
    const template = document.getElementById('competition-card-template');
    
    grid.innerHTML = '';
    
    if (competitions.length === 0) {
        grid.classList.add('hidden');
        emptyState.classList.remove('hidden');
        return;
    }
    
    grid.classList.remove('hidden');
    emptyState.classList.add('hidden');
    
    competitions.forEach(competition => {
        const card = template.content.cloneNode(true);
        
        // Fill in competition details
        card.querySelector('.competition-name').textContent = competition.nome;
        card.querySelector('.competition-code').textContent = competition.codice;
        
        // Show location (luogo) if available, otherwise show societa name or code
        let locationText = competition.luogo || competition.societa_nome || competition.societa_codice || 'TBA';
        card.querySelector('.competition-location').textContent = locationText;
        
        card.querySelector('.competition-date').textContent = formatDateRange(competition.data_inizio, competition.data_fine);
        card.querySelector('.competition-type').textContent = competition.tipo || 'Competition';
        
        // Get competition status (red/green/blue/white)
        const competitionStatus = getCompetitionStatus(competition);
        
        // Status badge with color
        const badge = card.querySelector('.competition-badge');
        badge.textContent = competitionStatus.label;
        badge.className = `competition-badge px-3 py-1 rounded-full text-xs font-semibold ${competitionStatus.color}`;
        
        // Subscription status and button logic
        const subscribeBtn = card.querySelector('.btn-subscribe');
        const unsubscribeBtn = card.querySelector('.btn-unsubscribe');
        const interestStatusBox = card.querySelector('.competition-interest-status');
        const interestDeleteBtn = card.querySelector('.btn-delete-interest');
        
        const subSummary = getSubscriptionSummary(competition.codice);
        
        // Check for interests
        const hasExpressedInterest = userInterests.has(competition.codice) && 
            userInterests.get(competition.codice).some(i => i.stato === 'attivo');
        const activeInterests = hasExpressedInterest ? 
            userInterests.get(competition.codice).filter(i => i.stato === 'attivo') : [];
        
        // Filter out interests for athletes who are already subscribed
        const subscribedTessere = new Set(subSummary.subscriptions
            .filter(s => s.stato !== 'cancellato')
            .map(s => s.tessera_atleta));
        const unsubscribedInterests = activeInterests.filter(
            interest => !subscribedTessere.has(interest.tessera_atleta)
        );
        
        // Show interest status if there are interests from athletes who are NOT subscribed
        if (unsubscribedInterests.length > 0) {
            interestStatusBox.classList.remove('hidden');
            const interestText = interestStatusBox.querySelector('.interest-status-text');
            const count = unsubscribedInterests.length;
            interestText.textContent = count === 1 ? 
                'Interesse espresso' : 
                `${count} interessati`;
            
            // Populate athlete list
            const athleteListContainer = interestStatusBox.querySelector('.athlete-list');
            athleteListContainer.innerHTML = unsubscribedInterests.map(interest => {
                const athlete = authorizedAthletes.find(a => a.tessera === interest.tessera_atleta);
                const athleteName = athlete ? athlete.display : interest.tessera_atleta;
                return `
                    <div class="text-xs text-yellow-800 dark:text-yellow-300 flex items-center justify-between">
                        <span>
                            <i class="fas fa-user mr-2"></i>${athleteName}
                            ${interest.categoria ? ` - ${interest.categoria}` : ''}
                            ${interest.classe ? ` - ${interest.classe}` : ''}
                        </span>
                    </div>
                `;
            }).join('');
            
            // Wire up delete button (pass only unsubscribed interests)
            interestDeleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showDeleteInterestModal(unsubscribedInterests, competition);
            });
        }
        
        if (subSummary.hasActiveSubscription) {
            // User has active subscriptions - show summary
            const statusBox = card.querySelector('.competition-subscription-status');
            statusBox.classList.remove('hidden');
            
            // Update status box based on primary subscription status
            const statusTextContainer = statusBox.querySelector('.flex.items-center.text-green-800');
            const statusIcon = statusTextContainer.querySelector('i');
            const statusText = statusTextContainer.querySelector('span');
            
            // Remove all color classes
            statusBox.classList.remove(
                'bg-green-50', 'dark:bg-green-900/20', 'border-green-200', 'dark:border-green-800',
                'bg-yellow-50', 'dark:bg-yellow-900/20', 'border-yellow-200', 'dark:border-yellow-800',
                'bg-red-50', 'dark:bg-red-900/20', 'border-red-200', 'dark:border-red-800',
                'bg-gray-50', 'dark:bg-gray-900/20', 'border-gray-200', 'dark:border-gray-800'
            );
            statusTextContainer.classList.remove(
                'text-green-800', 'dark:text-green-300',
                'text-yellow-800', 'dark:text-yellow-300',
                'text-red-800', 'dark:text-red-300',
                'text-gray-800', 'dark:text-gray-300'
            );
            
            // Apply styling based on primary status
            const colorMap = {
                'green': {
                    bg: ['bg-green-50', 'dark:bg-green-900/20', 'border-green-200', 'dark:border-green-800'],
                    text: ['text-green-800', 'dark:text-green-300']
                },
                'yellow': {
                    bg: ['bg-yellow-50', 'dark:bg-yellow-900/20', 'border-yellow-200', 'dark:border-yellow-800'],
                    text: ['text-yellow-800', 'dark:text-yellow-300']
                },
                'gray': {
                    bg: ['bg-gray-50', 'dark:bg-gray-900/20', 'border-gray-200', 'dark:border-gray-800'],
                    text: ['text-gray-800', 'dark:text-gray-300']
                }
            };
            
            const colors = colorMap[subSummary.statusColor];
            statusBox.classList.add(...colors.bg);
            statusTextContainer.classList.add(...colors.text);
            statusIcon.className = `${subSummary.statusIcon} mr-2`;
            statusText.textContent = subSummary.statusText;
            
            // Populate athlete list for subscriptions
            const athleteListContainer = statusBox.querySelector('.athlete-list');
            athleteListContainer.innerHTML = subSummary.activeSubs.map(sub => {
                const athlete = authorizedAthletes.find(a => a.tessera === sub.tessera_atleta);
                const athleteName = athlete ? athlete.display : sub.tessera_atleta;
                
                // Status badge
                let statusBadge = '';
                let textColor = colors.text.join(' ');
                if (sub.stato === 'confermato') {
                    statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300">Confermato</span>';
                } else if (sub.stato === 'in attesa') {
                    statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300">In attesa</span>';
                } else if (sub.stato === 'richiesta_effettuata') {
                    statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-900/30 dark:text-gray-300">Richiesta</span>';
                }
                
                return `
                    <div class="text-xs ${textColor} flex items-center justify-between">
                        <span>
                            <i class="fas fa-user mr-2"></i>${athleteName}
                            ${sub.categoria ? ` - ${sub.categoria}` : ''}
                            ${sub.classe ? ` - ${sub.classe}` : ''}
                            ${sub.turno ? ` - Turno ${sub.turno}` : ''}
                            ${statusBadge}
                        </span>
                    </div>
                `;
            }).join('');
            
            // Allow subscribing additional athletes if:
            // 1. User has multiple authorized athletes
            // 2. Not all athletes are subscribed (active subscriptions < total athletes)
            const canSubscribeMore = authorizedAthletes.length > 1 && 
                                      subSummary.activeSubs.length < authorizedAthletes.length;
            
            if (canSubscribeMore) {
                subscribeBtn.disabled = false;
                subscribeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                subscribeBtn.innerHTML = '<i class="fas fa-user-plus mr-2"></i>Aggiungi atleta';
            } else {
                subscribeBtn.disabled = true;
                subscribeBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            
            // Wire up delete button - show list of subscribed athletes to delete
            unsubscribeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showDeleteSubscriptionModal(subSummary.subscriptions, competition);
            });
        } else if (subSummary.allCancelled) {
            // All subscriptions cancelled - allow resubscription
            subscribeBtn.disabled = false;
            subscribeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            subscribeBtn.innerHTML = '<i class="fas fa-user-plus mr-2"></i>Iscriviti';
        } else {
            // Not subscribed - configure button based on competition status
            if (competitionStatus.canExpressInterest) {
                // Check if user already expressed interest (has interest in userInterests)
                const hasExpressedInterest = userInterests.has(competition.codice) && 
                    userInterests.get(competition.codice).some(i => i.stato === 'attivo');
                
                if (hasExpressedInterest) {
                    // Already expressed interest - allow re-expressing
                    subscribeBtn.innerHTML = '<i class="fas fa-star mr-2"></i>Mi interessa';
                    subscribeBtn.classList.remove('bg-primary', 'hover:bg-primary-dark', 'bg-yellow-500', 'hover:bg-yellow-600');
                    subscribeBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                    subscribeBtn.disabled = false;
                } else {
                    // Show "Mi interessa" button for competitions without invites
                    subscribeBtn.innerHTML = '<i class="fas fa-star mr-2"></i>Mi interessa';
                    subscribeBtn.classList.remove('bg-primary', 'hover:bg-primary-dark');
                    subscribeBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                    subscribeBtn.disabled = false;
                }
            } else if (competitionStatus.canSubscribe) {
                // Normal subscribe button
                subscribeBtn.innerHTML = '<i class="fas fa-user-plus mr-2"></i>Iscriviti';
                subscribeBtn.classList.add('bg-primary', 'hover:bg-primary-dark');
                subscribeBtn.disabled = false;
            } else {
                // Closed - cannot subscribe
                subscribeBtn.textContent = 'Chiuso';
                subscribeBtn.classList.remove('bg-primary', 'hover:bg-primary-dark');
                subscribeBtn.classList.add('bg-red-600', 'opacity-50', 'cursor-not-allowed');
                subscribeBtn.disabled = true;
            }
        }
        
        // Button actions
        subscribeBtn.addEventListener('click', () => {
            if (!subscribeBtn.disabled) {
                openSubscriptionModal(competition);
            }
        });
        
        grid.appendChild(card);
    });
}

async function openSubscriptionModal(competition) {
    // Get subscription summary to check who's already subscribed (NOT interested)
    const subSummary = getSubscriptionSummary(competition.codice);
    const subscribedAthletes = new Set(subSummary.subscriptions
        .filter(s => s.stato !== 'cancellato')
        .map(s => s.tessera_atleta));
    
    // Filter to only show athletes who aren't already subscribed (interests are allowed to be re-expressed)
    const availableAthletes = authorizedAthletes.filter(a => !subscribedAthletes.has(a.tessera));
    
    if (availableAthletes.length === 0) {
        showNotification('Tutti gli atleti sono già iscritti a questa gara', 'info');
        return;
    }
    
    // Populate modal with competition info
    document.getElementById('competition-id').value = competition.codice;
    document.getElementById('modal-competition-info').textContent = 
        `${competition.nome} - ${formatDate(competition.data_inizio)}`;
    
    // Load turns for this competition from Flask proxy
    try {
        const turnsResp = await fetch(`/archery/api/turni?codice_gara=${competition.codice}`);
        if (turnsResp.ok) {
            const turns = await turnsResp.json();
            
            console.log(`Turns for ${competition.codice}:`, turns);
            
            // Check if invite is published (has turns)
            if (!turns || turns.length === 0) {
                // No invite published - show "Express Interest" mode
                console.log(`No turns found for ${competition.codice} - showing express interest`);
                showExpressInterestMode(competition, availableAthletes);
                return;
            }
            
            // Has turns - show normal subscription mode
            console.log(`${turns.length} turns found for ${competition.codice} - showing normal subscription`);
            populateTurnsDropdown(turns);
            showNormalSubscriptionMode(competition, availableAthletes);
        } else {
            // API error - assume no invite, allow express interest
            console.log(`API error loading turns for ${competition.codice} - showing express interest`);
            showExpressInterestMode(competition, availableAthletes);
            return;
        }
    } catch (error) {
        console.error('Error loading turns:', error);
        showExpressInterestMode(competition, availableAthletes);
        return;
    }
}

function showNormalSubscriptionMode(competition, availableAthletes = null) {
    // Reset modal to normal subscription mode
    
    // Reset modal title
    document.getElementById('modal-title').textContent = 'Iscriviti alla Gara';
    
    // Show turn selection
    const turnContainer = document.getElementById('turn-selection-container');
    if (turnContainer) turnContainer.style.display = 'block';
    
    // Reset submit button text
    const submitBtn = document.getElementById('modal-submit-btn');
    if (submitBtn) {
        submitBtn.textContent = 'Conferma Iscrizione';
    }
    
    // Reset info message
    const infoEl = document.getElementById('modal-competition-info');
    infoEl.innerHTML = `<p class="text-gray-600 dark:text-gray-400">${competition.nome} - ${formatDate(competition.data_inizio)}</p>`;
    
    // Populate athlete dropdown (filter if provided)
    populateAthleteDropdown(availableAthletes);
    
    // Show modal
    document.getElementById('subscription-modal').classList.remove('hidden');
}

function showExpressInterestMode(competition, availableAthletes = null) {
    // Competition doesn't have published invite yet
    // Show modal with "Express Interest" instead of full subscription
    
    // Update modal title
    document.getElementById('modal-title').textContent = 'Esprimi Interesse';
    
    // Hide turn selection (no turns available)
    const turnContainer = document.getElementById('turn-selection-container');
    if (turnContainer) turnContainer.style.display = 'none';
    
    // Update submit button text
    const submitBtn = document.getElementById('modal-submit-btn');
    if (submitBtn) {
        submitBtn.textContent = 'Conferma Interesse';
    }
    
    // Add info message
    const infoEl = document.getElementById('modal-competition-info');
    infoEl.innerHTML = `
        <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg mb-4">
            <div class="flex items-start">
                <i class="fas fa-info-circle text-yellow-600 dark:text-yellow-400 mt-0.5 mr-2"></i>
                <div class="text-sm text-yellow-800 dark:text-yellow-300">
                    <strong>Invito Non Ancora Pubblicato</strong><br>
                    L'invito ufficiale per questa gara non è ancora stato pubblicato. Puoi esprimere interesse e ti avviseremo quando le iscrizioni saranno aperte.
                </div>
            </div>
        </div>
        <p class="text-gray-600 dark:text-gray-400">${competition.nome} - ${formatDate(competition.data_inizio)}</p>
    `;
    
    // Filter out athletes who already expressed interest
    const interestedAthletes = userInterests.get(competition.codice) || [];
    const interestedTessere = new Set(interestedAthletes.filter(i => i.stato === 'attivo').map(i => i.tessera_atleta));
    const filteredAthletes = availableAthletes ? availableAthletes.filter(a => !interestedTessere.has(a.tessera)) : null;
    
    // Populate athlete dropdown with filtered list
    populateAthleteDropdown(filteredAthletes);
    
    // Show modal
    document.getElementById('subscription-modal').classList.remove('hidden');
}

function populateTurnsDropdown(turns) {
    const select = document.getElementById('turn');
    select.innerHTML = `<option value="">Scegli turno...</option>`;
    
    turns.forEach(turn => {
        const option = document.createElement('option');
        option.value = turn.turno;
        // Build display text, only including non-null parts
        const parts = [];
        if (turn.giorno) parts.push(turn.giorno);
        if (turn.fase) parts.push(turn.fase);
        if (turn.ora_ritrovo) {
            // Format time from "08:45:00" to "08:45"
            // Convert to string if it's not already
            const timeStr = typeof turn.ora_ritrovo === 'string' ? turn.ora_ritrovo : String(turn.ora_ritrovo);
            const timeFormatted = timeStr.substring(0, 5);
            parts.push(timeFormatted);
        }
        option.textContent = parts.length > 0 ? parts.join(' - ') : `Turno ${turn.turno}`;
        select.appendChild(option);
    });
}

function populateAthleteDropdown(filteredAthletes = null) {
    const container = document.getElementById('athlete-select-container');
    const athletes = filteredAthletes || authorizedAthletes;
    
    console.log('populateAthleteDropdown: athletes=', athletes);
    
    if (athletes.length === 0) {
        container.innerHTML = '<p class="text-sm text-yellow-600 dark:text-yellow-400">No authorized athletes. Contact admin to add athletes to your account.</p>';
        return;
    }
    
    if (athletes.length === 1) {
        // Only one athlete - auto-select and hide dropdown, pre-fill form fields
        const athlete = athletes[0];
        console.log('Single athlete mode, pre-filling:', { categoria: athlete.categoria, classe: athlete.classe });
        container.innerHTML = `<input type="hidden" id="selected-athlete" value="${athlete.tessera}">
                              <p class="text-sm text-gray-600 dark:text-gray-400">Subscribing: ${athlete.display}</p>`;
        // Pre-fill age category and bow type from athlete data
        if (athlete.categoria) {
            const ageCategoryEl = document.getElementById('age-category');
            if (ageCategoryEl) {
                ageCategoryEl.value = athlete.categoria;
                console.log('Set age-category to:', athlete.categoria);
            }
        }
        if (athlete.classe) {
            const bowTypeEl = document.getElementById('bow-type');
            if (bowTypeEl) {
                bowTypeEl.value = athlete.classe;
                console.log('Set bow-type to:', athlete.classe);
            }
        }
        return;
    }
    
    // Multiple athletes - show dropdown with theme matching
    const select = document.createElement('select');
    select.id = 'selected-athlete';
    select.className = 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-primary focus:border-primary';
    
    select.innerHTML = '<option value="">Seleziona atleta...</option>';
    athletes.forEach(athlete => {
        const option = document.createElement('option');
        option.value = athlete.tessera;
        option.textContent = athlete.display;
        option.dataset.ageCategory = athlete.categoria || '';  // Changed from age_category to categoria
        option.dataset.bowType = athlete.classe || '';
        select.appendChild(option);
    });
    
    // Add event listener to pre-fill form when athlete is selected
    select.addEventListener('change', function(e) {
        const selectedOption = e.target.selectedOptions[0];
        if (selectedOption && selectedOption.value) {
            console.log('Athlete selected:', { 
                value: selectedOption.value, 
                ageCategory: selectedOption.dataset.ageCategory, 
                bowType: selectedOption.dataset.bowType 
            });
            // Pre-fill age category and bow type from selected athlete
            const ageCategoryEl = document.getElementById('age-category');
            const bowTypeEl = document.getElementById('bow-type');
            
            if (selectedOption.dataset.ageCategory && ageCategoryEl) {
                ageCategoryEl.value = selectedOption.dataset.ageCategory;
                console.log('Set age-category to:', selectedOption.dataset.ageCategory);
            }
            if (selectedOption.dataset.bowType && bowTypeEl) {
                bowTypeEl.value = selectedOption.dataset.bowType;
                console.log('Set bow-type to:', selectedOption.dataset.bowType);
            }
        } else {
            // Reset fields if no athlete selected
            document.getElementById('age-category').value = '';
            document.getElementById('bow-type').value = '';
        }
    });
    
    container.innerHTML = '';
    container.appendChild(select);
}

function closeSubscriptionModal() {
    document.getElementById('subscription-modal').classList.add('hidden');
    document.getElementById('subscription-form').reset();
}

async function submitSubscription() {
    const codiceGara = document.getElementById('competition-id').value;
    const turn = document.getElementById('turn').value;
    const tessera = document.getElementById('selected-athlete')?.value;
    const ageCategory = document.getElementById('age-category').value;
    const bowType = document.getElementById('bow-type').value;
    const notes = document.getElementById('notes').value;
    
    // Check if turn selection is visible (normal subscription) or hidden (express interest)
    const turnContainer = document.getElementById('turn-selection-container');
    const isExpressInterest = turnContainer && turnContainer.style.display === 'none';
    
    if (!isExpressInterest && !turn) {
        showNotification(window.translations.competitions?.select_turn_required || 'Seleziona un turno', 'warning');
        return;
    }
    
    if (!tessera) {
        showNotification('Seleziona un atleta', 'warning');
        return;
    }
    
    if (!ageCategory) {
        showNotification('Seleziona una categoria', 'warning');
        return;
    }
    
    if (!bowType) {
        showNotification('Seleziona un arco', 'warning');
        return;
    }
    
    try {
        // Submit to Flask proxy (which forwards to FastAPI with auth)
        // IMPORTANT: Field names are REVERSED between athlete data and iscrizioni API:
        // - From athlete: categoria=age_category, classe=bow_type
        // - To iscrizioni: categoria=bow_type, classe=age_category
        
        let response, result;
        
        if (isExpressInterest) {
            // Use interesse API for interest expressions
            response = await fetch(`/archery/api/interesse`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    codice_gara: codiceGara,
                    tessera_atleta: tessera,
                    categoria: bowType,             // Bow type: CO (Compound), OL (Olympic), AN (Barebow)
                    classe: ageCategory,            // Age category: SM, SF, MM, MF, etc.
                    note: notes
                })
            });
        } else {
            // Use iscrizioni API for actual subscriptions
            response = await fetch(`/archery/api/iscrizioni`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    codice_gara: codiceGara,
                    tessera_atleta: tessera,
                    categoria: bowType,             // Bow type: CO (Compound), OL (Olympic), AN (Barebow)
                    classe: ageCategory,            // Age category: SM, SF, MM, MF, GM, GF, RM, RF, AM, AF, JM, JF
                    turno: parseInt(turn),
                    stato: 'in attesa',  // Pending - admin must confirm manually
                    note: notes
                })
            });
        }
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || (isExpressInterest ? 'Errore nell\'espressione di interesse' : 'Errore nell\'iscrizione'));
        }
        
        result = await response.json();
        console.log(isExpressInterest ? 'Interest response:' : 'Subscription response:', result);
        
        // Validate response has required id field
        if (!result || !result.id) {
            console.error('Invalid API response - missing id field:', result);
            throw new Error('Risposta del server non valida');
        }
        
        if (isExpressInterest) {
            // Create interest object from response
            const interest = {
                id: result.id,
                codice_gara: codiceGara,
                tessera_atleta: tessera,
                categoria: bowType,
                classe: ageCategory,
                stato: 'attivo',
                note: notes
            };
            
            // Add to interests array
            if (!userInterests.has(codiceGara)) {
                userInterests.set(codiceGara, []);
            }
            userInterests.get(codiceGara).push(interest);
        } else {
            // Create subscription object from response
            const subscription = {
                id: result.id,
                codice_gara: codiceGara,
                tessera_atleta: tessera,
                categoria: bowType,
                classe: ageCategory,
                turno: parseInt(turn),
                stato: 'in attesa',
                note: notes
            };
            
            // Add to subscriptions array
            if (!userSubscriptions.has(codiceGara)) {
                userSubscriptions.set(codiceGara, []);
            }
            userSubscriptions.get(codiceGara).push(subscription);
        }
        
        closeSubscriptionModal();
        showNotification(
            isExpressInterest ? 
                'Interesse espresso con successo!' : 
                (window.translations.competitions?.subscription_success || 'Iscrizione effettuata con successo!'), 
            'success'
        );
        filterCompetitions(currentFilter);
    } catch (error) {
        console.error('Error subscribing:', error);
        showNotification(error.message || window.translations.competitions?.subscription_error || 'Errore nell\'iscrizione', 'error');
    }
}

function showDeleteSubscriptionModal(subscriptions, competition) {
    const activeSubs = subscriptions.filter(s => s.stato !== 'cancellato');
    if (activeSubs.length === 0) return;
    
    // For single subscription, delete directly with simple confirm
    if (activeSubs.length === 1) {
        deleteSubscription(activeSubs[0], competition);
        return;
    }
    
    // For multiple subscriptions, show selection modal
    const modal = document.getElementById('delete-subscription-modal');
    const competitionInfo = document.getElementById('delete-modal-competition-info');
    const subscriptionsList = document.getElementById('delete-subscriptions-list');
    
    competitionInfo.textContent = `${competition.nome} - ${formatDate(competition.data_inizio)}`;
    
    // Build checkboxes for each subscription
    subscriptionsList.innerHTML = '';
    activeSubs.forEach(sub => {
        const athlete = authorizedAthletes.find(a => a.tessera === sub.tessera_atleta);
        const athleteName = athlete ? athlete.display : sub.tessera_atleta;
        
        // Status badge
        let statusBadge = '';
        if (sub.stato === 'confermato') {
            statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300">Confermato</span>';
        } else if (sub.stato === 'in attesa') {
            statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300">In attesa</span>';
        } else if (sub.stato === 'richiesta_effettuata') {
            statusBadge = '<span class="ml-2 px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-900/30 dark:text-gray-300">Richiesta</span>';
        }
        
        const checkbox = document.createElement('label');
        checkbox.className = 'flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-750 cursor-pointer';
        checkbox.innerHTML = `
            <input type="checkbox" value="${sub.id}" class="subscription-delete-checkbox h-4 w-4 text-primary border-gray-300 dark:border-gray-600 rounded focus:ring-primary">
            <span class="ml-3 flex-1 text-sm text-gray-900 dark:text-white">
                ${athleteName}${statusBadge}
                <span class="block text-xs text-gray-500 dark:text-gray-400 mt-1">
                    ${sub.categoria || ''} - ${sub.classe || ''} - Turno ${sub.turno}
                </span>
            </span>
        `;
        subscriptionsList.appendChild(checkbox);
    });
    
    // Store competition reference for later
    modal.dataset.competitionCode = competition.codice;
    
    modal.classList.remove('hidden');
}

function closeDeleteModal() {
    document.getElementById('delete-subscription-modal').classList.add('hidden');
}

async function confirmDeleteSelected() {
    const modal = document.getElementById('delete-subscription-modal');
    const checkboxes = modal.querySelectorAll('.subscription-delete-checkbox:checked');
    const idsToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    if (idsToDelete.length === 0) {
        showNotification('Seleziona almeno un\'iscrizione da eliminare', 'warning');
        return;
    }
    
    const competitionCode = modal.dataset.competitionCode;
    
    try {
        // Delete all selected subscriptions
        await Promise.all(idsToDelete.map(id => deleteSubscriptionInternal(id)));
        
        // Update local cache - remove deleted subscriptions
        if (userSubscriptions.has(competitionCode)) {
            const remaining = userSubscriptions.get(competitionCode)
                .filter(sub => !idsToDelete.includes(sub.id));
            if (remaining.length > 0) {
                userSubscriptions.set(competitionCode, remaining);
            } else {
                userSubscriptions.delete(competitionCode);
            }
        }
        
        closeDeleteModal();
        showNotification(
            idsToDelete.length === 1 ? 
                'Iscrizione eliminata con successo' : 
                `${idsToDelete.length} iscrizioni eliminate con successo`, 
            'success'
        );
        filterCompetitions(currentFilter);
    } catch (error) {
        console.error('Error deleting subscriptions:', error);
        showNotification('Errore durante l\'eliminazione delle iscrizioni', 'error');
    }
}

async function deleteSubscriptionInternal(subscriptionId) {
    const response = await fetch(`/archery/api/iscrizioni/${subscriptionId}`, {
        method: 'DELETE'
    });
    
    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Delete failed');
    }
    
    return response.json();
}

async function deleteSubscription(subscription, competition) {
    // Confirm before deleting
    const confirmMsg = window.translations.competitions?.confirm_delete || 
        `Are you sure you want to delete your subscription to ${competition.nome}?`;
    
    if (!confirm(confirmMsg)) {
        return;
    }
    
    try {
        const response = await fetch(`/archery/api/iscrizioni/${subscription.id}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Delete failed');
        }
        
        // Remove from local cache
        userSubscriptions.delete(competition.codice);
        
        showNotification(window.translations.competitions?.delete_success || 'Subscription deleted successfully', 'success');
        
        // Refresh the competition list
        filterCompetitions(currentFilter);
    } catch (error) {
        console.error('Error deleting subscription:', error);
        showNotification(error.message || window.translations.competitions?.delete_error || 'Failed to delete subscription', 'error');
    }
}

// Interest deletion functions
function showDeleteInterestModal(interests, competition) {
    const activeInterests = interests.filter(i => i.stato === 'attivo');
    if (activeInterests.length === 0) return;
    
    // For single interest, delete directly with simple confirm
    if (activeInterests.length === 1) {
        deleteInterest(activeInterests[0], competition);
        return;
    }
    
    // For multiple interests, show selection modal (reuse subscription modal structure)
    const modal = document.getElementById('delete-subscription-modal');
    const competitionInfo = document.getElementById('delete-modal-competition-info');
    const subscriptionsList = document.getElementById('delete-subscriptions-list');
    
    // Change modal title
    const modalTitle = modal.querySelector('h2');
    if (modalTitle) modalTitle.textContent = 'Rimuovi Interesse';
    
    competitionInfo.textContent = `${competition.nome} - ${formatDate(competition.data_inizio)}`;
    
    // Build checkboxes for each interest
    subscriptionsList.innerHTML = '';
    activeInterests.forEach(interest => {
        const athlete = authorizedAthletes.find(a => a.tessera === interest.tessera_atleta);
        const athleteName = athlete ? athlete.display : interest.tessera_atleta;
        
        const checkbox = document.createElement('label');
        checkbox.className = 'flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer';
        checkbox.innerHTML = `
            <input type="checkbox" value="${interest.id}" class="interest-delete-checkbox h-4 w-4 text-primary border-gray-300 dark:border-gray-600 rounded focus:ring-primary">
            <span class="ml-3 flex-1 text-sm text-gray-900 dark:text-white">
                ${athleteName}
                <span class="block text-xs text-gray-500 dark:text-gray-400 mt-1">
                    ${interest.categoria || ''} - ${interest.classe || ''}
                    ${interest.note ? ' - ' + interest.note : ''}
                </span>
            </span>
        `;
        subscriptionsList.appendChild(checkbox);
    });
    
    // Store competition reference and mark as interest mode
    modal.dataset.competitionCode = competition.codice;
    modal.dataset.deleteMode = 'interest';
    
    // Update confirm button to call interest deletion
    const confirmBtn = modal.querySelector('button[onclick="confirmDeleteSelected()"]');
    if (confirmBtn) {
        confirmBtn.onclick = confirmDeleteSelectedInterests;
    }
    
    modal.classList.remove('hidden');
}

async function confirmDeleteSelectedInterests() {
    const modal = document.getElementById('delete-subscription-modal');
    const checkboxes = modal.querySelectorAll('.interest-delete-checkbox:checked');
    const idsToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    if (idsToDelete.length === 0) {
        showNotification('Seleziona almeno un interesse da eliminare', 'warning');
        return;
    }
    
    const competitionCode = modal.dataset.competitionCode;
    
    try {
        // Delete all selected interests
        await Promise.all(idsToDelete.map(id => deleteInterestInternal(id)));
        
        // Update local cache - remove deleted interests
        if (userInterests.has(competitionCode)) {
            const remaining = userInterests.get(competitionCode)
                .filter(interest => !idsToDelete.includes(interest.id));
            if (remaining.length > 0) {
                userInterests.set(competitionCode, remaining);
            } else {
                userInterests.delete(competitionCode);
            }
        }
        
        closeDeleteModal();
        showNotification(
            idsToDelete.length === 1 ? 
                'Interesse rimosso con successo' : 
                `${idsToDelete.length} interessi rimossi con successo`,
            'success'
        );
        
        // Restore modal title and button for next use
        const modalTitle = modal.querySelector('h2');
        if (modalTitle) modalTitle.textContent = 'Elimina Iscrizione';
        const confirmBtn = modal.querySelector('button[onclick="confirmDeleteSelectedInterests()"]');
        if (confirmBtn) {
            confirmBtn.onclick = confirmDeleteSelected;
        }
        
        filterCompetitions(currentFilter);
    } catch (error) {
        console.error('Error deleting interests:', error);
        showNotification('Errore durante la rimozione degli interessi', 'error');
    }
}

async function deleteInterest(interest, competition) {
    const athlete = authorizedAthletes.find(a => a.tessera === interest.tessera_atleta);
    const athleteName = athlete ? athlete.display : interest.tessera_atleta;
    
    const confirmMsg = `Rimuovere l'interesse di ${athleteName} per ${competition.nome}?`;
    
    if (!confirm(confirmMsg)) {
        return;
    }
    
    try {
        await deleteInterestInternal(interest.id);
        
        // Remove from local cache
        if (userInterests.has(competition.codice)) {
            const remaining = userInterests.get(competition.codice)
                .filter(i => i.id !== interest.id);
            if (remaining.length > 0) {
                userInterests.set(competition.codice, remaining);
            } else {
                userInterests.delete(competition.codice);
            }
        }
        
        showNotification('Interesse rimosso con successo', 'success');
        filterCompetitions(currentFilter);
    } catch (error) {
        console.error('Error deleting interest:', error);
        showNotification('Errore durante la rimozione dell\'interesse', 'error');
    }
}

async function deleteInterestInternal(interestId) {
    const response = await fetch(`/archery/api/interesse/${interestId}`, {
        method: 'DELETE'
    });
    
    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Delete failed');
    }
    
    return response.json();
}

function showCompetitionDetails(competition) {
    // TODO: Implement details modal or redirect to details page
    console.log('Show details for:', competition);
    showNotification('Competition details coming soon', 'info');
}

function toggleAthleteList(element) {
    // Find the athlete list container within the same status box
    const statusBox = element.closest('.competition-subscription-status, .competition-interest-status');
    const athleteList = statusBox.querySelector('.athlete-list');
    const toggleIcon = element.querySelector('.athlete-list-toggle');
    
    if (athleteList.classList.contains('hidden')) {
        athleteList.classList.remove('hidden');
        toggleIcon.classList.remove('fa-chevron-down');
        toggleIcon.classList.add('fa-chevron-up');
    } else {
        athleteList.classList.add('hidden');
        toggleIcon.classList.remove('fa-chevron-up');
        toggleIcon.classList.add('fa-chevron-down');
    }
}

function formatDate(dateStr) {
    if (!dateStr) return 'TBA';
    const date = new Date(dateStr);
    const locale = window.translations._lang === 'it' ? 'it-IT' : 'en-US';
    
    if (locale === 'it-IT') {
        // Italian format: 17-Ott-2025
        const day = date.getDate();
        const monthShort = date.toLocaleDateString('it-IT', { month: 'short' });
        const year = date.getFullYear();
        return `${day}-${monthShort.charAt(0).toUpperCase() + monthShort.slice(1)}-${year}`;
    }
    
    return date.toLocaleDateString(locale, {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
}

function formatDateRange(startStr, endStr) {
    if (!startStr) return 'TBA';
    const start = new Date(startStr);
    const end = endStr ? new Date(endStr) : null;
    
    const locale = window.translations._lang === 'it' ? 'it-IT' : 'en-US';
    
    if (locale === 'it-IT') {
        // Italian format: 17-Ott or 17-18 Ott or 17 Ott - 20 Nov
        const startDay = start.getDate();
        const startMonthShort = start.toLocaleDateString('it-IT', { month: 'short' });
        const startMonth = startMonthShort.charAt(0).toUpperCase() + startMonthShort.slice(1);
        
        if (end && end.getTime() !== start.getTime()) {
            const endDay = end.getDate();
            const endMonthShort = end.toLocaleDateString('it-IT', { month: 'short' });
            const endMonth = endMonthShort.charAt(0).toUpperCase() + endMonthShort.slice(1);
            
            if (start.getMonth() === end.getMonth()) {
                // Same month: 17-18 Ott
                return `${startDay}-${endDay} ${startMonth}`;
            } else {
                // Different months: 28 Ott - 2 Nov
                return `${startDay} ${startMonth} - ${endDay} ${endMonth}`;
            }
        }
        
        return `${startDay} ${startMonth}`;
    }
    
    // English format
    const startFormatted = start.toLocaleDateString(locale, { month: 'short', day: 'numeric' });
    
    if (end && end.getTime() !== start.getTime()) {
        const endFormatted = end.toLocaleDateString(locale, { month: 'short', day: 'numeric', year: 'numeric' });
        return `${startFormatted} - ${endFormatted}`;
    }
    
    return start.toLocaleDateString(locale, { year: 'numeric', month: 'long', day: 'numeric' });
}

function showLoading(show) {
    console.log('showLoading called with:', show);
    const loading = document.getElementById('loading');
    const grid = document.getElementById('competitions-grid');
    const emptyState = document.getElementById('empty-state');
    
    if (show) {
        loading.classList.remove('hidden');
        grid.classList.add('hidden');
        emptyState.classList.add('hidden');
        console.log('Spinner shown');
    } else {
        loading.classList.add('hidden');
        grid.classList.remove('hidden');
        console.log('Spinner hidden, grid shown');
    }
}

function showError(message) {
    showNotification(message, 'error');
    document.getElementById('empty-state').classList.remove('hidden');
}
</script>

{% endblock %}
